#!/usr/bin/env python
# twisted imports
from twisted.words.protocols import irc
from twisted.internet import reactor, protocol
from threading import Lock

import sys, os, re, stat
import datetime
import time
import requests
import pickle
import pprint

import jubjubconfig

class JubJub(irc.IRCClient):

    def __init__(self):
        self.lastbreaktime = 0;
        self.lastbreaktype = "";
        self.message = re.compile('^'+self.nickname+'[:,] ?(.*)')
        self.config = jubjubconfig.read_config()
        self.nickname = self.config.get('irc','nickname')
        self.username = self.config.get('irc','username')

        reactor.callLater(30,self.ping_pong)

        if self.config != None and self.config.getboolean('log','enabled'):
            self.logpath = os.path.expanduser(self.config.get('log','path'))

        self.database = JubJubDatabase(self.config.get('database', 'path'))

        self.teabreaklength = self.config.getint('misc','teabreaklength')

        # Set up the modules
        self.modulenames = self.config.get('irc', 'modules').replace(' ','').split(',')
        self.modulenames = filter(None, self.modulenames)

        m = __import__('modules', globals(), locals(), self.modulenames, -1)

        self.modules = []
        for modulename in self.modulenames:
            self.modules.append(getattr(m, modulename).JubJubModule(self))

        self.users = dict()
        # used in NAMES command
        self.userlock = dict()

    def signedOn(self):
        """Called when bot has succesfully signed on to server."""
        channel = self.config.get('irc', 'chan')
        self.userlock[channel] = Lock()
        self.users[channel] = dict()
        self.join(channel)

    #module calls

    def module_call(self, func, *arg):
        for module in self.modules:
            if hasattr(module, func):
                getattr(module, func)(*arg)

    def connectionMade(self):
        irc.IRCClient.connectionMade(self)
        self.module_call('on_connect', channel)

    def joined(self, channel):
        self.module_call('on_chan_join', channel)

    def privmsg(self, username, channel, msg):
        self.module_call('on_message', username, channel, msg)

    def userJoined(self, username, channel):
        self.users[channel][JubJubUser.realname(username)] = JubJubUser(self, username, channel)
        self.module_call('on_user_join', username, channel)

    def userLeft(self, username, channel):
        del(self.users[channel][JubJubUser.realname(username)])
        self.module_call('on_user_leave', username, channel)

    def modeChanged(self, user, channel, s, modes, args):
        if 'o' in modes:
            for username in args:
                try:
                    self.users[channel][JubJubUser.realname(username)].is_op = s
                except:
                    pass

    ####
    def get_users(self, channel):
        return self.users[channel].values()

    def _update_users(self, channel):
        channel = channel.lower()
        self.users[channel].clear()
        self.sendLine("NAMES %s" % channel)
        self.userlock[channel].acquire()
        return self.users[channel].values()

    def irc_RPL_NAMREPLY(self, prefix, params):
        print 'NAMREPLY:' + str(params)
        channel = params[2].lower()
        for username in params[3].split(' '):
            # don't add ourselves
            rn = JubJubUser.realname(username)
            if rn != self.nickname and rn != '':
                self.users[channel][rn] = JubJubUser(self, username, channel)

    def irc_RPL_ENDOFNAMES(self, prefix, params):
        print 'ENDOFNAMES:' + str(params)
        lock = self.userlock[params[1].lower()]
        if lock.locked():
            lock.release()

    ### old
    def ping_pong(self):
        self.sendLine("PING :Ph33r!")
        reactor.callLater(30,self.ping_pong)

    def connectionMade(self):
        irc.IRCClient.connectionMade(self)

    def connectionLost(self, reason):
        irc.IRCClient.connectionLost(self, reason)

    def irc_unknown(self, prefix, command, params):
        if command=="PONG":
            return
        print prefix,command,params

    def notice(self, user, channel, msg):
        print user,"NOTICE",channel,msg

    def cmd_help(self,user,channel,args):
        self.say(channel," ".join([x[4:]
                for x in dir(self.__class__)
                if x.startswith("cmd_")]))

    def do_command(self,user,channel,cmd):
        cmd,args=(cmd+" ").split(" ",1)
        cmd="cmd_"+cmd.lower()
        if cmd in dir(self.__class__):
            getattr(self.__class__,cmd)(self,user,channel,args)

    def cmd_useradd(self,user,channel,args):
        args = args.strip(' ')
#        if user in self.ops and args not in self.ops:
        if args not in self.ops:
            self.ops.append(args)
            self.save_users()
            self.say(channel, "Added %s" % args)

    def cmd_userdel(self,user,channel,args):
        args = args.strip(' ')
        if user in self.ops and args in self.ops:
            self.ops.remove(args)
            self.save_users()
            self.say(channel, "Removed %s" % args)

    def cmd_userlist(self,user,channel,args):
        args = args.strip()
        if user in self.ops:
            self.say(channel,"Users: " + " ".join(self.ops))
        else:
            self.say(channel,"Permission denied")

    def save_users(self):
        self.database.save()

    def log_break(self,channel,user,msg):
        line = list()
        start = datetime.datetime.fromtimestamp(self.lastbreaktime)
        end = datetime.datetime.fromtimestamp(self.lastbreaktime+self.teabreaklength)
        line.append(start.strftime("%d/%m/%y|%H:%M:%S"))
        line.append(end.strftime("%d/%m/%y|%H:%M:%S"))
        line.append(self.lastbreaktype)
        line.append(channel)
        line.append(user)
        line.append(msg)
        try:
            with open(self.logpath, 'a') as file:
                file.write(' '.join(line) + '\n')
        except:
            pass

class JubJubFactory(protocol.ClientFactory):
    # the class of the protocol to build when new connection is made
    protocol = JubJub

    def clientConnectionLost(self, connector, reason):
        """If we get disconnected, reconnect to server."""
        time.sleep(30)
        connector.connect()

    def clientConnectionFailed(self, connector, reason):
        print "connection failed:", reason
        time.sleep(30)
        connector.connect()

class JubJubDatabase():

    data = dict()

    def __init__(self, filename):
        self.load(filename)

    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        else:
            return None

    def __setitem__(self, key, value):
        self.data[key] = value

    def load(self, filename):
        self.filename = os.path.realpath(filename)
        try:
            with open(self.filename, 'r') as f:
                self.data = pickle.load(f)
        except:
            print 'Failed to load database'
            data = dict()
        pprint.PrettyPrinter(indent=4).pprint(self.data)

    def save(self):
        parent = os.path.dirname(self.filename)
        if not os.path.exists(parent):
            print 'creating path '+parent
            os.makedirs(parent)
        try:
            print 'pickling:'
            pprint.PrettyPrinter(indent=4).pprint(self.data)
            with open(self.filename, 'w') as f:
                pickle.dump(self.data, f)
        except IOError, e:
            print e.errno
            print e

class JubJubUser():

    #need to handle joins, mod change, leaves

    def __init__(self, bot, username, channel):
        self.bot = bot
        self.is_op = username[0] == '@'
        username = JubJubUser.realname(username)
        self.username = username
        self.channel = channel

    def __hash__(self):
        return hash((self.username, self.channel))

    def __eq__(self, other):
        return (self.username, self.location) == (other.username, other.channel)

    @staticmethod
    def realname(username):
        if len(username) > 1 and username[0] == '@':
            username = username[1:]
        return username


if __name__ == '__main__':
    # create factory protocol and application
    f = JubJubFactory()

    config = jubjubconfig.read_config()

    # connect factory to this host and port
    reactor.connectTCP(config.get("irc","host"), config.getint("irc","port"), f)

    # run bot
    reactor.run()

# vim: set smartindent shiftwidth=4 tabstop=4 softtabstop=4 expandtab :
