#!/usr/bin/env python
# twisted imports
from twisted.words.protocols import irc
from twisted.internet import reactor, protocol

import sys, os, re, stat
import datetime
import time
import requests
import pickle
import pprint

import jubjubconfig

class JubJub(irc.IRCClient):

    def __init__(self):
        self.lastbreaktime = 0;
        self.lastbreaktype = "";
        self.message = re.compile('^'+self.nickname+'[:,] ?(.*)')
        self.config = jubjubconfig.read_config()
        self.nickname = self.config.get('irc','nickname')
        self.username = self.config.get('irc','username')

        reactor.callLater(30,self.ping_pong)

        if self.config != None and self.config.getboolean('log','enabled'):
            self.logpath = os.path.expanduser(self.config.get('log','path'))

        self.database = JubJubDatabase(self.config.get('database', 'path'))

        self.teabreaklength = self.config.getint('misc','teabreaklength')

        self.ops = self.database['ops']
        if self.ops == None:
            self.ops = []
            self.database['ops'] = self.ops

    def __human_time_diff(self, seconds):
        """ Convert seconds into human readable time periods """
        if seconds < 0:
            seconds = 0
        timediffstr = ""
        if seconds > 3600:
            timediffstr += str(seconds/3600)+" hour(s) "
            seconds -= (seconds/3600)*3600
        if seconds > 60:
            timediffstr += str(seconds/60)+" minute(s) "
            seconds -= (seconds/60)*60
        if seconds > 0 or timediffstr == "":
            timediffstr += str(seconds)+" second(s)"
        return timediffstr.strip()

    def ping_pong(self):
        self.sendLine("PING :Ph33r!")
        reactor.callLater(30,self.ping_pong)

    def connectionMade(self):
        irc.IRCClient.connectionMade(self)

    def connectionLost(self, reason):
        irc.IRCClient.connectionLost(self, reason)

    # callbacks for events

    def signedOn(self):
        """Called when bot has succesfully signed on to server."""
        self.join(self.config.get('irc','chan'))

    def irc_unknown(self, prefix, command, params):
        if command=="PONG":
            return
        print prefix,command,params

    def notice(self, user, channel, msg):
        print user,"NOTICE",channel,msg

    def cmd_help(self,user,channel,args):
        self.say(channel," ".join([x[4:]
                for x in dir(self.__class__)
                if x.startswith("cmd_")]))

    def cmd_op(self,user,channel,args):
        self.mode(channel,"+","o",user=user)

    def do_command(self,user,channel,cmd):
        cmd,args=(cmd+" ").split(" ",1)
        cmd="cmd_"+cmd.lower()
        if cmd in dir(self.__class__):
            getattr(self.__class__,cmd)(self,user,channel,args)

    def privmsg(self, user, channel, msg):
        """This will get called when the bot receives a message."""
        print user,"PRIVMSG",channel,msg

        user = user.split('!', 1)[0]

        # is the message at us?
        splitmsg = self.message.match(msg.lower())
        if splitmsg:
            splitmsg = splitmsg.group(1).strip()
            if "when" in splitmsg.lower() and "last" in splitmsg.lower():
                if self.lastbreaktime > 0:
                    currenttime = int(time.time())
                    timediffstr = self.__human_time_diff(currenttime - self.lastbreaktime)
                    self.say(channel, "The last break was a "+self.lastbreaktype+", it happened "+timediffstr+" ago at "+datetime.datetime.fromtimestamp(self.lastbreaktime).strftime('%H:%M'))
            elif "break" in splitmsg.lower():
                if "lunch" in splitmsg.lower():
                    breaktype = "lunchbreak"
                elif "beer" in splitmsg.lower():
                    breaktype = "beerbreak"
                else:
                    breaktype = "teabreak"
                if user in self.ops:
                    print "** "+breaktype.upper()+" DETECTED **",user,"has called a "+breaktype
                    nowbreak = int(time.time())
                    if (nowbreak - self.lastbreaktime) >= self.teabreaklength:
                        self.lastbreaktime = nowbreak
                        self.lastbreaktype = breaktype
                        teabreakcount = 0
                    else:
                        print "** "+breaktype.upper()+" DENIED ** Please wait another "+self.__human_time_diff(self.teabreaklength - (nowbreak - self.lastbreaktime))+" before calling a break"
                        self.say(channel, breaktype+" denied! Please wait another "+self.__human_time_diff(self.teabreaklength - (nowbreak - self.lastbreaktime))+" before calling a break")
                else:
                    print "** UNAUTHORISED USER",user,"ATTEMPTED TO CALL A "+breaktype.upper()+" **"
                    self.say(channel, breaktype+" denied! You need ops to call a break")

        if channel[0] in ['#','&']:
            if msg.startswith("!"):# and user in self.ops:
                self.do_command(user,channel,msg[1:].strip())

    def userJoined(self, user, channel):
        print user,"JOINED",channel
        if user in self.ops:
            self.cmd_op(user, channel, None)

    def cmd_useradd(self,user,channel,args):
        args = args.strip(' ')
#        if user in self.ops and args not in self.ops:
        if args not in self.ops:
            self.ops.append(args)
            self.save_users()
            self.say(channel, "Added %s" % args)

    def cmd_userdel(self,user,channel,args):
        args = args.strip(' ')
        if user in self.ops and args in self.ops:
            self.ops.remove(args)
            self.save_users()
            self.say(channel, "Removed %s" % args)

    def cmd_userlist(self,user,channel,args):
        args = args.strip()
        if user in self.ops:
            self.say(channel,"Users: " + " ".join(self.ops))
        else:
            self.say(channel,"Permission denied")

    def save_users(self):
        self.database.save()

    def log_break(self,channel,user,msg):
        line = list()
        start = datetime.datetime.fromtimestamp(self.lastbreaktime)
        end = datetime.datetime.fromtimestamp(self.lastbreaktime+self.teabreaklength)
        line.append(start.strftime("%d/%m/%y|%H:%M:%S"))
        line.append(end.strftime("%d/%m/%y|%H:%M:%S"))
        line.append(self.lastbreaktype)
        line.append(channel)
        line.append(user)
        line.append(msg)
        try:
            with open(self.logpath, 'a') as file:
                file.write(' '.join(line) + '\n')
        except:
            pass

class JubJubFactory(protocol.ClientFactory):
    # the class of the protocol to build when new connection is made
    protocol = JubJub

    def clientConnectionLost(self, connector, reason):
        """If we get disconnected, reconnect to server."""
        time.sleep(30)
        connector.connect()

    def clientConnectionFailed(self, connector, reason):
        print "connection failed:", reason
        time.sleep(30)
        connector.connect()

class JubJubDatabase():

    data = dict()

    def __init__(self, filename):
        self.load(filename)

    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        else:
            return None

    def __setitem__(self, key, value):
        self.data[key] = value

    def load(self, filename):
        self.filename = os.path.realpath(filename)
        try:
            with open(self.filename, 'r') as f:
                self.data = pickle.load(f)
        except:
            print 'Failed to load database'
            data = dict()
        pprint.PrettyPrinter(indent=4).pprint(self.data)

    def save(self):
        parent = os.path.dirname(self.filename)
        if not os.path.exists(parent):
            print 'creating path '+parent
            os.makedirs(parent)
        try:
            print 'pickling:'
            pprint.PrettyPrinter(indent=4).pprint(self.data)
            with open(self.filename, 'w') as f:
                pickle.dump(self.data, f)
        except IOError, e:
            print e.errno
            print e


if __name__ == '__main__':
    # create factory protocol and application
    f = JubJubFactory()

    config = jubjubconfig.read_config()

    # connect factory to this host and port
    reactor.connectTCP(config.get("irc","host"), config.getint("irc","port"), f)

    # run bot
    reactor.run()

# vim: set smartindent shiftwidth=4 tabstop=4 softtabstop=4 expandtab :
